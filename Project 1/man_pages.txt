termios(3), tcgetattr(3), tcsetattr(3)

TERMIOS(3)                 Linux Programmer's Manual                TERMIOS(3)

NAME
       termios,  tcgetattr,  tcsetattr, tcsendbreak, tcdrain, tcflush, tcflow,
       cfmakeraw, cfgetospeed, cfgetispeed, cfsetispeed,  cfsetospeed,  cfset‐
       speed - get and set terminal attributes, line control, get and set baud
       rate

SYNOPSIS
       #include <termios.h>
       #include <unistd.h>

       int tcgetattr(int fd, struct termios *termios_p);

       int tcsetattr(int fd, int optional_actions,
                     const struct termios *termios_p);

       int tcsendbreak(int fd, int duration);

       int tcdrain(int fd);

       int tcflush(int fd, int queue_selector);

       int tcflow(int fd, int action);

       void cfmakeraw(struct termios *termios_p);

       speed_t cfgetispeed(const struct termios *termios_p);

       speed_t cfgetospeed(const struct termios *termios_p);

       int cfsetispeed(struct termios *termios_p, speed_t speed);

       int cfsetospeed(struct termios *termios_p, speed_t speed);

       int cfsetspeed(struct termios *termios_p, speed_t speed);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       cfsetspeed(), cfmakeraw(): _BSD_SOURCE

DESCRIPTION
       The termios functions describe a general  terminal  interface  that  is
       provided to control asynchronous communications ports.

   The termios structure
       Many  of the functions described here have a termios_p argument that is
       a pointer to a termios structure.  This structure contains at least the
       following members:

           tcflag_t c_iflag;      /* input modes */
           tcflag_t c_oflag;      /* output modes */
           tcflag_t c_cflag;      /* control modes */
           tcflag_t c_lflag;      /* local modes */
           cc_t     c_cc[NCCS];   /* special characters */
        The  values  that  may be assigned to these fields are described below.
        In the case of the first four bit-mask fields, the definitions of  some
        of  the associated flags that may be set are exposed only if a specific
        feature test macro (see feature_test_macros(7)) is defined, as noted in
        brackets ("[]").

        In  the  descriptions below, "not in POSIX" means that the value is not
        specified in POSIX.1-2001, and "XSI" means that the value is  specified
        in POSIX.1-2001 as part of the XSI extension.

======

fork()

FORK(2)                     Linux Programmer's Manual                    FORK(2)

NAME
       fork - create a child process

SYNOPSIS
       #include <unistd.h>

       pid_t fork(void);

DESCRIPTION
       fork() creates a new process by duplicating the calling process.  The new
       process, referred to as the child, is an exact duplicate of  the  calling
       process, referred to as the parent, except for the following points:

       *  The  child  has its own unique process ID, and this PID does not match
          the ID of any existing process group (setpgid(2)).

       *  The child's parent process ID is the same as the parent's process ID.

       *  The child does not inherit its parent's memory locks (mlock(2), mlock‐
          all(2)).

       *  Process  resource  utilizations  (getrusage(2))  and CPU time counters
          (times(2)) are reset to zero in the child.

       *  The child's set of pending signals is initially empty (sigpending(2)).

       *  The child does not  inherit  semaphore  adjustments  from  its  parent
          (semop(2)).

       *  The child does not inherit record locks from its parent (fcntl(2)).

       *  The  child  does  not  inherit  timers  from its parent (setitimer(2),
          alarm(2), timer_create(2)).

       *  The child does not inherit  outstanding  asynchronous  I/O  operations
          from  its  parent (aio_read(3), aio_write(3)), nor does it inherit any
          asynchronous I/O contexts from its parent (see io_setup(2)).

RETURN VALUE
     On success, the PID of the child process is returned in the parent, and 0
     is  returned  in the child.  On failure, -1 is returned in the parent, no
     child process is created, and errno is set appropriately.

ERRORS
     EAGAIN fork() cannot allocate sufficient memory to copy the parent's page
            tables and allocate a task structure for the child.

     EAGAIN It  was  not possible to create a new process because the caller's
            RLIMIT_NPROC resource  limit  was  encountered.   To  exceed  this
            limit,  the  process  must  have  either  the CAP_SYS_ADMIN or the
            CAP_SYS_RESOURCE capability.

     ENOMEM fork() failed to allocate the necessary kernel structures  because
            memory is tight.

     ENOSYS fork()  is  not  supported on this platform (for example, hardware
            without a Memory-Management Unit).

     ERESTARTNOINTR (since Linux 2.6.17)
            System call was interrupted by a signal  and  will  be  restarted.
            (This can be seen only during a trace.)

======

wait()

WAIT(2)                     Linux Programmer's Manual                    WAIT(2)

NAME
       wait, waitpid, waitid - wait for process to change state

SYNOPSIS
       #include <sys/types.h>
       #include <sys/wait.h>

       pid_t wait(int *status);

       pid_t waitpid(pid_t pid, int *status, int options);

       int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       waitid():
           _SVID_SOURCE || _XOPEN_SOURCE >= 500 ||
           _XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED
           || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L

DESCRIPTION
       All of these system calls are used to wait for state changes in  a  child
       of  the  calling  process,  and  obtain information about the child whose
       state has changed.  A state change is considered to be: the child  termi‐
       nated;  the  child was stopped by a signal; or the child was resumed by a
       signal.  In the case of a terminated child, performing a wait allows  the
       system  to  release the resources associated with the child; if a wait is
       not performed, then the terminated child remains in a "zombie" state (see
       NOTES below).

       If  a  child  has  already changed state, then these calls return immedi‐
       ately.  Otherwise they block until either a child changes state or a sig‐
       nal handler interrupts the call (assuming that system calls are not auto‐
       matically restarted using the SA_RESTART flag of sigaction(2)).   In  the
       remainder of this page, a child whose state has changed and which has not
       yet been waited upon by one of these system calls is termed waitable.

   wait() and waitpid()
       The wait() system call suspends execution of the  calling  process  until
       one of its children terminates.  The call wait(&status) is equivalent to:

           waitpid(-1, &status, 0);

RETURN VALUE
wait(): on success, returns the process ID of the  terminated  child;  on
error, -1 is returned.

waitpid():  on  success,  returns the process ID of the child whose state
has changed; if WNOHANG was specified and one or more  child(ren)  speci‐
fied  by  pid  exist, but have not yet changed state, then 0 is returned.
On error, -1 is returned.

waitid(): returns 0 on  success  or  if  WNOHANG  was  specified  and  no
child(ren)  specified  by  id  has  yet  changed  state;  on error, -1 is
returned.  Each of these calls sets errno to an appropriate value in  the
case of an error.

ERRORS
ECHILD (for  wait())  The  calling process does not have any unwaited-for
     children.

ECHILD (for waitpid() or waitid()) The process specified  by  pid  (wait‐
     pid())  or  idtype  and  id  (waitid()) does not exist or is not a
     child of the calling process.  (This  can  happen  for  one's  own
     child  if  the action for SIGCHLD is set to SIG_IGN.  See also the
     Linux Notes section about threads.)

EINTR  WNOHANG was not set and an  unblocked  signal  or  a  SIGCHLD  was
     caught; see signal(7).

EINVAL The options argument was invalid.

======

exec()

EXEC(3)                     Linux Programmer's Manual                    EXEC(3)

NAME
       execl, execlp, execle, execv, execvp, execvpe - execute a file

SYNOPSIS
       #include <unistd.h>

       extern char **environ;

       int execl(const char *path, const char *arg, ...);
       int execlp(const char *file, const char *arg, ...);
       int execle(const char *path, const char *arg,
                  ..., char * const envp[]);
       int execv(const char *path, char *const argv[]);
       int execvp(const char *file, char *const argv[]);
       int execvpe(const char *file, char *const argv[],
                   char *const envp[]);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       execvpe(): _GNU_SOURCE

DESCRIPTION
       The  exec() family of functions replaces the current process image with a
       new process image.  The functions  described  in  this  manual  page  are
       front-ends for execve(2).  (See the manual page for execve(2) for further
       details about the replacement of the current process image.)

       The initial argument for these functions is the name of a file that is to
       be executed.

       The const char *arg and subsequent ellipses in the execl(), execlp(), and
       execle() functions can be thought of as arg0, arg1, ..., argn.   Together
       they  describe  a list of one or more pointers to null-terminated strings
       that represent the argument list available to the executed program.   The
       first  argument,  by  convention, should point to the filename associated
       with the file being executed.  The list of arguments must  be  terminated
       by  a NULL pointer, and, since these are variadic functions, this pointer
       must be cast (char *) NULL.

RETURN VALUE
      The  exec()  functions  return only if an error has occurred.  The return
      value is -1, and errno is set to indicate the error.

ERRORS
      All of these functions may fail and set errno for any of the errors spec‐
      ified for execve(2).

======

pipe()

PIPE(2)                     Linux Programmer's Manual                    PIPE(2)

NAME
       pipe, pipe2 - create pipe

SYNOPSIS
       #include <unistd.h>

       int pipe(int pipefd[2]);

       #define _GNU_SOURCE             /* See feature_test_macros(7) */
       #include <fcntl.h>              /* Obtain O_* constant definitions */
       #include <unistd.h>

       int pipe2(int pipefd[2], int flags);

DESCRIPTION
       pipe() creates a pipe, a unidirectional data channel that can be used for
       interprocess communication.  The array pipefd is used to return two  file
       descriptors  referring  to the ends of the pipe.  pipefd[0] refers to the
       read end of the pipe.  pipefd[1] refers to the write  end  of  the  pipe.
       Data written to the write end of the pipe is buffered by the kernel until
       it is read from the read end of  the  pipe.   For  further  details,  see
       pipe(7).

       If  flags is 0, then pipe2() is the same as pipe().  The following values
       can be bitwise ORed in flags to obtain different behavior:

       O_NONBLOCK  Set the O_NONBLOCK file status flag on the two new open  file
                   descriptions.   Using this flag saves extra calls to fcntl(2)
                   to achieve the same result.

       O_CLOEXEC   Set the close-on-exec (FD_CLOEXEC) flag on the two  new  file
                   descriptors.  See the description of the same flag in open(2)
                   for reasons why this may be useful.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set
       appropriately.

ERRORS
       EFAULT pipefd is not valid.

       EINVAL (pipe2()) Invalid value in flags.

       EMFILE Too many file descriptors are in use by the process.

       ENFILE The  system  limit  on  the  total  number  of open files has been
              reached.

======

kill (3)

KILL(3P)                    POSIX Programmer's Manual                   KILL(3P)

PROLOG
       This  manual  page  is  part of the POSIX Programmer's Manual.  The Linux
       implementation of this interface may differ  (consult  the  corresponding
       Linux  manual  page  for details of Linux behavior), or the interface may
       not be implemented on Linux.

NAME
       kill - send a signal to a process or a group of processes

SYNOPSIS
       #include <signal.h>

       int kill(pid_t pid, int sig);

DESCRIPTION
       The kill() function shall send a signal to a process or a group  of  pro‐
       cesses specified by pid. The signal to be sent is specified by sig and is
       either one from the list given in <signal.h> or 0. If sig is 0 (the  null
       signal),  error checking is performed but no signal is actually sent. The
       null signal can be used to check the validity of pid.

RETURN VALUE
      Upon  successful  completion, 0 shall be returned. Otherwise, -1 shall be
      returned and errno set to indicate the error.

ERRORS
      The kill() function shall fail if:

      EINVAL The value of the sig argument is an invalid or unsupported  signal
             number.

      EPERM  The  process  does  not  have permission to send the signal to any
             receiving process.

      ESRCH  No process or process group can be  found  corresponding  to  that
             specified by pid.

      The following sections are informative.

======

POLL(2)                     Linux Programmer's Manual                    POLL(2)

NAME
       poll, ppoll - wait for some event on a file descriptor

SYNOPSIS
       #include <poll.h>

       int poll(struct pollfd *fds, nfds_t nfds, int timeout);

       #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <poll.h>

       int ppoll(struct pollfd *fds, nfds_t nfds,
               const struct timespec *timeout_ts, const sigset_t *sigmask);

DESCRIPTION
       poll() performs a similar task to select(2): it waits for one of a set of
       file descriptors to become ready to perform I/O.

       The set of file descriptors to be monitored is specified in the fds argu‐
       ment, which is an array of structures of the following form:

           struct pollfd {
               int   fd;         /* file descriptor */
               short events;     /* requested events */
               short revents;    /* returned events */
           };

       The caller should specify the number of items in the fds array in nfds.

RETURN VALUE
      On success, a positive number is returned; this is the number  of  struc‐
      tures  which  have nonzero revents fields (in other words, those descrip‐
      tors with events or errors reported).  A value of 0  indicates  that  the
      call  timed  out  and  no  file  descriptors were ready.  On error, -1 is
      returned, and errno is set appropriately.

ERRORS
      EFAULT The array given as argument was not contained in the calling  pro‐
             gram's address space.

      EINTR  A signal occurred before any requested event; see signal(7).

      EINVAL The nfds value exceeds the RLIMIT_NOFILE value.

      ENOMEM There was no space to allocate file descriptor tables.

======

https://www.gnu.org/software/libc/manual/html_node/Noncanon-Example.html
https://ece.uwaterloo.ca/~dwharder/icsrts/Tutorials/fork_exec/
http://tldp.org/LDP/lpg/node11.html

======

http://www.cs.rpi.edu/~moorthy/Courses/os98/Pgms/socket.html
http://www.cs.rpi.edu/~moorthy/Courses/os98/Pgms/server.c
http://www.cs.rpi.edu/~moorthy/Courses/os98/Pgms/client.c
